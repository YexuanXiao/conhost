#include "console_handoff_proxy_registration.hpp"

#include <atomic>
#include <new>

#include <objbase.h>
#include <objidl.h>

#include "IConsoleHandoff.h"

struct ProxyFileInfo;

// The proxy/stub sources generated by MIDL define these entry points.
extern "C" HRESULT STDAPICALLTYPE DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);
extern "C" void RPC_ENTRY GetProxyDllInfo(const ProxyFileInfo*** pProxyFileInfo, const CLSID** pClsid);

namespace
{
    [[nodiscard]] const CLSID* resolve_proxy_clsid() noexcept
    {
        const ProxyFileInfo** info = nullptr;
        const CLSID* clsid = nullptr;
        GetProxyDllInfo(&info, &clsid);
        return clsid;
    }

}

namespace oc::tests
{
    ConsoleHandoffProxyRegistration::~ConsoleHandoffProxyRegistration() noexcept
    {
        if (_registered)
        {
            ::CoRevokeClassObject(_cookie);
        }

        if (_class_object != nullptr)
        {
            static_cast<IUnknown*>(_class_object)->Release();
            _class_object = nullptr;
        }
    }

    [[nodiscard]] HRESULT ConsoleHandoffProxyRegistration::register_for_process() noexcept
    {
        if (_registered)
        {
            return S_OK;
        }

        const CLSID* clsid = resolve_proxy_clsid();
        if (clsid == nullptr)
        {
            return E_UNEXPECTED;
        }

        IPSFactoryBuffer* ps_factory = nullptr;
        const HRESULT factory_hr = ::DllGetClassObject(*clsid, IID_IPSFactoryBuffer, reinterpret_cast<void**>(&ps_factory));
        if (FAILED(factory_hr) || ps_factory == nullptr)
        {
            return FAILED(factory_hr) ? factory_hr : E_NOINTERFACE;
        }

        const HRESULT register_hr = ::CoRegisterClassObject(
            *clsid,
            static_cast<IUnknown*>(ps_factory),
            CLSCTX_INPROC_SERVER,
            REGCLS_MULTIPLEUSE,
            &_cookie);

        if (FAILED(register_hr))
        {
            ps_factory->Release();
            return register_hr;
        }

        // Tell COM which proxy CLSID to use when marshalling these interfaces
        // within the current process.
        const HRESULT ps_console = ::CoRegisterPSClsid(IID_IConsoleHandoff, *clsid);
        const HRESULT ps_marker = ::CoRegisterPSClsid(IID_IDefaultTerminalMarker, *clsid);
        if (FAILED(ps_console) || FAILED(ps_marker))
        {
            ::CoRevokeClassObject(_cookie);
            _cookie = 0;
            ps_factory->Release();
            return FAILED(ps_console) ? ps_console : ps_marker;
        }

        _class_object = ps_factory;
        _registered = true;
        return S_OK;
    }
}
